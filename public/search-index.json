[
  {
    "slug": "embedded-ai/echo-mate-face-recognition",
    "title": "RV1106嵌入式人脸识别系统开发实战",
    "description": "基于Rockchip RV1106开发AI桌面机器人，实现RetinaFace人脸检测、LVGL界面、RKNN模型推理的完整开发流程及踩坑记录",
    "category": "embedded-ai",
    "tags": [
      "RV1106",
      "RKNN",
      "人脸识别",
      "RetinaFace",
      "LVGL",
      "嵌入式AI"
    ],
    "content": " RV1106嵌入式人脸识别系统开发实战 本文记录了在 Rockchip RV1106 平台上开发 AI 桌面机器人 Echo-Mate 人脸识别功能的完整过程，包括模型部署、UI开发、以及各种踩坑解决方案。 项目概述 硬件平台 | 组件 | 规格 | |------|------| | CPU | Rockchip RV1106 (ARM Cortex-A7) | | NPU | 0.5 TOPS RKNPU | | 内存 | 64MB DDR2 | | 显示 | 320x240 LCD | | 摄像头 | UYVY格式，支持ISP | 功能特性 - 人脸检测: 使用 RetinaFace RKNN 模型，640x640 输入 - 人脸识别: 简化版特征匹配（可扩展 MobileFaceNet） - 用户界面: LVGL 8.x，三个标签页（识别/注册/管理） - 本地存储: 人脸数据库保存到文件系统 系统架构 技术栈 模型 | 模型 | 用途 | 输入尺寸 | 备注 | |------|------|----------|------| | RetinaFace | 人脸检测 | 640x640 RGB | 输出bbox + 5关键点 | | MobileFaceNet | 特征提取 | 112x112 RGB | 预留，当前使用简化匹配 | 软件库 | 库 | 用途 | |-----|------| | RKNN SDK | NPU模型推理 | | OpenCV-Mobile | 图像处理、摄像头采集 | | LVGL 8.x | 嵌入式GUI | | pthread | 多线程采集 | 核心代码实现 1. RetinaFace 模型推理 RetinaFace 输出三个张量，需要正确解码： 2. 摄像头采集线程 3. LVGL UI 定时更新 踩坑记录与解决方案 问题1: 画面显示绿色/蓝色噪点 现象: 摄像头画面出现大量绿色和蓝色小点，物体边缘尤其明显。 原因: 对 BGR565 格式的图像进行 时，双线性插值会跨越颜色通道的位边界，导致颜色错乱。 问题2: 无人脸时误检测 现象: 即使画面中没有人脸，系统也显示 \"Face detected\"，置信度异常高（30-60）。 原因: 模型输出类型是 （type=2），但代码使用 读取。 问题3: 边界框坐标为"
  },
  {
    "slug": "embedded-linux/arm-linux-dev-setup",
    "title": "ARM Linux开发环境搭建完全指南",
    "description": "从零开始搭建ARM Linux交叉编译环境，包括工具链安装、NFS配置、TFTP下载等完整流程",
    "category": "embedded-linux",
    "tags": [
      "Linux",
      "ARM",
      "交叉编译",
      "嵌入式开发"
    ],
    "content": " ARM Linux开发环境搭建完全指南 在嵌入式Linux开发中，搭建一个高效的开发环境是至关重要的。本文将详细介绍如何从零开始搭建完整的ARM Linux开发环境。 1. 交叉编译工具链 1.1 什么是交叉编译 交叉编译是指在一个平台上生成另一个平台可执行代码的过程。在嵌入式开发中，我们通常在x86主机上编译ARM平台的代码。 1.2 安装交叉编译工具链 1.3 配置环境变量 2. 开发板连接 2.1 串口连接 使用USB转串口线连接开发板的调试串口： 2.2 网络连接 配置NFS用于文件共享： 3. TFTP服务器配置 TFTP用于下载内核和设备树： 4. 编译第一个程序 4.1 编写测试程序 4.2 交叉编译 4.3 运行测试 将编译好的程序复制到NFS目录，然后在开发板上运行： 5. Makefile模板 以下是一个常用的Makefile模板： 6. 常见问题解决 6.1 动态库找不到 6.2 权限问题 总结 本文介绍了ARM Linux开发环境的基本搭建流程，包括： - 交叉编译工具链的安装和配置 - 串口和网络连接设置 - TFTP和NFS服务配置 - 基本的编译和调试流程 下一篇文章将介绍如何编译Linux内核和设备树。 "
  },
  {
    "slug": "embedded-linux/linux-kernel-module",
    "title": "Linux内核模块开发入门",
    "description": "学习Linux内核模块的基本概念，编写第一个内核模块，理解模块的加载和卸载过程",
    "category": "embedded-linux",
    "tags": [
      "Linux",
      "内核",
      "驱动开发",
      "内核模块"
    ],
    "content": " Linux内核模块开发入门 Linux内核模块是Linux内核的重要组成部分，允许在不重新编译内核的情况下动态添加功能。本文将带你编写第一个内核模块。 1. 内核模块概述 1.1 什么是内核模块 内核模块是一段可以被内核动态加载和卸载的代码，它扩展了内核的功能而不需要重启系统。 1.2 模块的优点 - 动态加载，无需重启 - 节省内存 - 方便调试和开发 2. 开发环境准备 3. 第一个内核模块 3.1 模块代码 3.2 Makefile 4. 编译和测试 4.1 编译模块 编译后会生成以下文件： - - 内核模块文件 - - - - - 4.2 加载模块 4.3 卸载模块 5. 模块参数 内核模块支持命令行参数： 使用参数加载模块： 6. 模块导出符号 导出符号供其他模块使用： 7. 常用API 7.1 内存分配 7.2 打印调试信息 8. 注意事项 1. 不能使用标准C库 - 内核模块不能使用libc函数 2. 没有内存保护 - 错误可能导致系统崩溃 3. 不能使用浮点运算 - 除非显式保存/恢复FPU状态 4. 同步很重要 - 注意并发访问和竞态条件 5. GPL许可证 - 许多内核API仅对GPL模块可用 总结 本文介绍了Linux内核模块开发的基础知识： - 内核模块的概念和优点 - 模块的编写和Makefile配置 - 模块的加载、卸载和调试 - 模块参数和符号导出 下一篇文章将介绍字符设备驱动的开发。 "
  },
  {
    "slug": "ros/ros2-first-node",
    "title": "ROS2入门：创建你的第一个节点",
    "description": "从零开始学习ROS2，创建发布者和订阅者节点，理解ROS2的基本概念和通信机制",
    "category": "ros",
    "tags": [
      "ROS2",
      "机器人",
      "Python",
      "节点通信"
    ],
    "content": " ROS2入门：创建你的第一个节点 ROS2（Robot Operating System 2）是新一代机器人操作系统，相比ROS1有了很多改进。本文将带你创建第一个ROS2节点。 1. ROS2安装 1.1 系统要求 推荐使用Ubuntu 22.04 LTS，安装ROS2 Humble版本： 2. 创建工作空间 2.1 工作空间结构 2.2 创建功能包 3. 编写发布者节点 3.1 Python版本 3.2 C++版本 4. 编写订阅者节点 4.1 Python版本 5. 编译和运行 5.1 编译 5.2 运行节点 6. 常用ROS2命令 7. launch文件 创建launch文件同时启动多个节点： 运行launch文件： 总结 本文介绍了ROS2的基础知识： - ROS2安装和环境配置 - 工作空间和功能包的创建 - 发布者和订阅者节点的编写 - 编译、运行和调试方法 下一篇文章将介绍ROS2的服务和动作通信机制。 "
  }
]